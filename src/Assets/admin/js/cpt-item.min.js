/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lite/admin/js/cpt-item.ts":
/*!***********************************!*\
  !*** ./lite/admin/js/cpt-item.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cpt_item_shortcodes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cpt-item/shortcodes */ "./lite/admin/js/cpt-item/shortcodes.ts");
/* harmony import */ var _cpt_item_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cpt-item/view */ "./lite/admin/js/cpt-item/view.ts");
/* harmony import */ var _cpt_item_card__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cpt-item/card */ "./lite/admin/js/cpt-item/card.ts");
/* harmony import */ var _cpt_item_request_blocker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cpt-item/request-blocker */ "./lite/admin/js/cpt-item/request-blocker.ts");




customElements.define('av-shortcodes', _cpt_item_shortcodes__WEBPACK_IMPORTED_MODULE_0__["default"]);
new _cpt_item_view__WEBPACK_IMPORTED_MODULE_1__["default"]();
new _cpt_item_card__WEBPACK_IMPORTED_MODULE_2__["default"]();
// acf-input is declared as dependency, so we can use it here
// it must be early call, before DOM ready, otherwise ACF will already render fields
var avSlugSelect = window['acf'].models.SelectField.extend({
  type: 'av_slug_select'
});
window['acf'].registerFieldType(avSlugSelect);

/***/ }),

/***/ "./lite/admin/js/cpt-item/card.ts":
/*!****************************************!*\
  !*** ./lite/admin/js/cpt-item/card.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _postbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./postbox */ "./lite/admin/js/cpt-item/postbox.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings */ "./lite/admin/js/cpt-item/settings.ts");
/* harmony import */ var _preview__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./preview */ "./lite/admin/js/cpt-item/preview.ts");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var CARD_DATA = {
  PREVIEW_TAB: '#acf-local_acf_views_acf-card-data li .acf-tab-button[data-key=local_acf_views_acf-card-data__preview-tab]',
  PREVIEW_FIELD: '#acf-local_acf_views_acf-card-data__preview',
  POST_BOX: '#acf-local_acf_views_acf-card-data'
};
var Card = /*#__PURE__*/function (_PostBox) {
  _inherits(Card, _PostBox);
  var _super = _createSuper(Card);
  function Card() {
    _classCallCheck(this, Card);
    return _super.apply(this, arguments);
  }
  _createClass(Card, [{
    key: "initialize",
    value: function initialize() {
      _get(_getPrototypeOf(Card.prototype), "initialize", this).call(this);
      if (!document.body.querySelector(CARD_DATA.POST_BOX)) {
        return;
      }
      this.init();
      this.initializePreview();
    }
  }, {
    key: "initializePreview",
    value: function initializePreview() {
      if (!_settings__WEBPACK_IMPORTED_MODULE_1__["default"].hasOwnProperty('cardPreview') || !_settings__WEBPACK_IMPORTED_MODULE_1__["default"].cardPreview.hasOwnProperty('HTML') || !_settings__WEBPACK_IMPORTED_MODULE_1__["default"].cardPreview.hasOwnProperty('CSS') || !_settings__WEBPACK_IMPORTED_MODULE_1__["default"].cardPreview.hasOwnProperty('HOME')) {
        console.log('Preview properties are missing');
        return;
      }
      var preview = new _preview__WEBPACK_IMPORTED_MODULE_2__["default"](CARD_DATA.PREVIEW_TAB, CARD_DATA.PREVIEW_FIELD, _settings__WEBPACK_IMPORTED_MODULE_1__["default"].cardPreview['HTML'], _settings__WEBPACK_IMPORTED_MODULE_1__["default"].cardPreview['CSS'], _settings__WEBPACK_IMPORTED_MODULE_1__["default"].cardPreview['HOME'], _settings__WEBPACK_IMPORTED_MODULE_1__["default"].cardPreview['VIEW_CSS']);
      preview.initialize();
    }
  }]);
  return Card;
}(_postbox__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Card);

/***/ }),

/***/ "./lite/admin/js/cpt-item/code-field.ts":
/*!**********************************************!*\
  !*** ./lite/admin/js/cpt-item/code-field.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _my_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./my-element */ "./lite/admin/js/cpt-item/my-element.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings */ "./lite/admin/js/cpt-item/settings.ts");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var CODE_FIELD_DATA = {
  CODE_FIELD: 'acf-views__code-field',
  CODE_FIELD__FULL_SCREEN: 'acf-views__code-field--full-screen',
  FULL_SCREEN: 'acf-views__full-screen'
};
var isAutoCompleteRegistered = false;
var CodeField = /*#__PURE__*/function (_MyElement) {
  _inherits(CodeField, _MyElement);
  var _super = _createSuper(CodeField);
  function CodeField(postBox, tab, textarea, mode, isReadOnly, linkTitle, isWithVariableAutocomplete) {
    var _this;
    _classCallCheck(this, CodeField);
    _this = _super.call(this);
    _this.postBox = postBox;
    _this.tab = tab;
    _this.textarea = textarea;
    _this.mode = mode;
    _this.isReadOnly = isReadOnly;
    _this.isToolbarPanelOpen = false;
    _this.originalNavItems = '';
    _this.linkTitle = linkTitle;
    _this.isWithVariableAutocomplete = isWithVariableAutocomplete;
    _this.makeCallback = null;
    _this.fullScreenSwitcher = null;
    return _this;
  }
  _createClass(CodeField, [{
    key: "toggleToAnotherField",
    value: function toggleToAnotherField(event) {
      event.preventDefault();
      var link = event.target.closest('a');
      if (link.classList.contains('av-toolbar__tab--active')) {
        return;
      }
      var targetId = link.dataset.targetId;
      var codeField = this.postBox.getCodeFieldById(targetId);
      // 1. hide the current code field
      this.toggleFullScreen(null, true);
      // 2. open the right tab (potentially will initially the code field)
      if (!codeField.tab.classList.contains('active')) {
        codeField.tab.querySelector('a').click();
      }
      // 3. pass the state of the toolbar panel
      codeField.isToolbarPanelOpen = this.isToolbarPanelOpen;
      // 4. open the new code field
      codeField.toggleFullScreen(null, true);
    }
  }, {
    key: "toggleNavItems",
    value: function toggleNavItems(isEnteringFullScreen) {
      var _this2 = this;
      var navItems = document.querySelector('.av-toolbar__block--type--left');
      var blockTypeRight = document.querySelector('.av-toolbar__block--type--right');
      blockTypeRight.style.display = isEnteringFullScreen ? 'none' : '';
      if (!isEnteringFullScreen) {
        navItems.innerHTML = this.originalNavItems;
        return;
      }
      this.originalNavItems = navItems.innerHTML;
      navItems.innerHTML = '';
      var codeFields = this.postBox.getCodeFields();
      codeFields.forEach(function (codeField) {
        var link = document.createElement('a');
        link.classList.add('av-toolbar__tab');
        link.dataset.targetId = codeField.getFieldId();
        link.href = '#';
        var span = document.createElement('span');
        span.innerText = codeField.linkTitle;
        link.append(span);
        if (_this2 === codeField) {
          link.classList.add('av-toolbar__tab--active');
        }
        link.addEventListener('click', _this2.toggleToAnotherField.bind(_this2));
        navItems.append(link);
      });
    }
    // entering full screen: closes toolbar panel, if it is open
    // exiting full screen: restores toolbar panel, if it was open
  }, {
    key: "maybeToggleToolbarPanel",
    value: function maybeToggleToolbarPanel(isEnteringFullScreen) {
      var openPanelButton = document.querySelector('.interface-pinned-items .components-button[aria-label="Settings"]');
      var isPanelOpenNow = openPanelButton.classList.contains('is-pressed');
      if (isEnteringFullScreen) {
        this.isToolbarPanelOpen = isPanelOpenNow;
        if (isPanelOpenNow) {
          openPanelButton.click();
        }
        return;
      }
      if (!this.isToolbarPanelOpen || isPanelOpenNow) {
        return;
      }
      openPanelButton.click();
    }
  }, {
    key: "toggleFullScreen",
    value: function toggleFullScreen(event) {
      var isSwitching = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var acfInputWrapper = this.getAcfInputWrapper();
      acfInputWrapper.classList.toggle(CODE_FIELD_DATA.CODE_FIELD__FULL_SCREEN);
      var isEnteringFullScreen = acfInputWrapper.classList.contains(CODE_FIELD_DATA.CODE_FIELD__FULL_SCREEN);
      var title = isEnteringFullScreen ? 'Collapse' : 'Expand';
      this.fullScreenSwitcher.setAttribute('title', title);
      this.toggleNavItems(isEnteringFullScreen);
      if (!isSwitching) {
        this.maybeToggleToolbarPanel(isEnteringFullScreen);
      }
    }
  }, {
    key: "syncTextareaAndEditor",
    value: function syncTextareaAndEditor(editor, mode) {
      var _this3 = this;
      // to avoid recursion
      var isExternalEvent = false;
      editor.getSession().on('change', function () {
        var value = editor.getSession().getValue();
        // PHP is added on ACF field_save hook to avoid issues with security plugins like WordFence
        if ('_php' === mode) {
          value = value.replace("<?php\n", "")
          // if user removed the line, we still need to remove the PHP tag
          .replace("<?php", "");
        }
        _this3.textarea.value = value;
        isExternalEvent = true;
        // notify potential listeners, e.g. fields-changed notice
        _this3.textarea.dispatchEvent(new Event('change'));
        isExternalEvent = false;
      });
      // update, if the value was reloaded
      this.textarea.addEventListener('change', function () {
        if (isExternalEvent) {
          return;
        }
        editor.getSession().setValue(_this3.textarea.value);
        // when editor is visible, setValue automatically redraws it
        if (_this3.tab.classList.contains('active')) {
          return;
        }
        var resize = function resize() {
          editor.resize();
          _this3.tab.removeEventListener('click', resize);
        };
        _this3.tab.addEventListener('click', resize);
      });
    }
  }, {
    key: "extensionBeautify",
    value: function extensionBeautify(editor) {
      editor.commands.addCommand({
        name: 'Beautify',
        bindKey: {
          win: 'Ctrl-Alt-L',
          linux: 'Ctrl-Alt-L',
          mac: 'Command-Alt-L'
        },
        exec: function exec(editor) {
          var beautify = window['ace'].require('ace/ext/beautify');
          beautify.beautify(editor.session);
        },
        // false if this command should not apply in readOnly mode
        readOnly: false
      });
    }
  }, {
    key: "extensionLinking",
    value: function extensionLinking(editor) {
      editor.on('linkClick', function (data) {
        if (!data || !data.token || 'comment' !== data.token.type) {
          return;
        }
        var link = data.token.value.match(/(http|https):\/\/[^\s\\*]+/g)[0] || '';
        if (!link) {
          return;
        }
        window.open(link, '_blank');
      });
    }
  }, {
    key: "maybeRegisterCompleter",
    value: function maybeRegisterCompleter(langTools) {
      var _this4 = this;
      if (isAutoCompleteRegistered) {
        return;
      }
      isAutoCompleteRegistered = true;
      // we skip the text completer, because it is too generic
      langTools.setCompleters([langTools.keyWordCompleter]);
      langTools.addCompleter({
        getCompletions: function getCompletions(editor, session, pos, prefix, callback) {
          _this4.postBox.getCompletions(editor, session, pos, prefix, callback);
        },
        id: 'customVariablesCompleter'
      });
    }
  }, {
    key: "makeEditor",
    value: function makeEditor(editorsElement, settings, mode) {
      var _this5 = this;
      var extensions = ['language_tools', 'linking'];
      extensions.forEach(function (extension) {
        var ext = window['ace'].require("ace/ext/".concat(extension));
        switch (extension) {
          case 'language_tools':
            _this5.maybeRegisterCompleter(ext);
            break;
        }
      });
      var editor = window['ace'].edit(editorsElement, settings);
      // PHP is stripped on ACF field_load hook to avoid issues with security plugins like WordFence
      var value = '_php' === mode ? "<?php\n" + this.textarea.value : this.textarea.value;
      // for CSS it's buggy, so keep it available by Ctrl + Space only.
      var isLiveAutocompletionEnabled = '_css' !== mode;
      editor.setOptions({
        theme: "ace/theme/nord_dark",
        value: value,
        showPrintMargin: false,
        fontSize: "15px",
        readOnly: this.isReadOnly,
        enableBasicAutocompletion: true,
        enableLiveAutocompletion: isLiveAutocompletionEnabled,
        enableLinking: true
      });
      this.syncTextareaAndEditor(editor, mode);
      this.extensionBeautify(editor);
      this.extensionLinking(editor);
      // todo remove if the 'worker-css' adds the nesting rules support.
      // https://github.com/ajaxorg/ace/issues/5559
      if ('_css' === mode) {
        editor.getSession().setUseWorker(false);
      }
      if (this.isWithVariableAutocomplete) {
        this.postBox.setEditorWithVariableAutocomplete(editor);
      }
    }
  }, {
    key: "getAcfInputWrapper",
    value: function getAcfInputWrapper() {
      return this.textarea.parentElement;
    }
  }, {
    key: "makeFullScreenModeSwitcher",
    value: function makeFullScreenModeSwitcher() {
      this.fullScreenSwitcher = document.createElement('div');
      this.fullScreenSwitcher.classList.add(CODE_FIELD_DATA.FULL_SCREEN);
      this.fullScreenSwitcher.innerHTML = '<span>[</span><span>]</span>';
      this.fullScreenSwitcher.setAttribute('title', 'Expand');
      this.fullScreenSwitcher.addEventListener('click', this.toggleFullScreen.bind(this));
      this.getAcfInputWrapper().append(this.fullScreenSwitcher);
    }
  }, {
    key: "make",
    value: function make() {
      if (this.makeCallback) {
        window['acf'].removeAction('show_field/name=' + this.getFieldId(), this.makeCallback);
        this.makeCallback = null;
      }
      var allSettings = JSON.parse(JSON.stringify(_settings__WEBPACK_IMPORTED_MODULE_1__["default"]['mods']));
      var acfInputWrapper = this.getAcfInputWrapper();
      acfInputWrapper.classList.add(CODE_FIELD_DATA.CODE_FIELD);
      this.textarea.style.display = 'none';
      acfInputWrapper.style.padding = '15px 0';
      acfInputWrapper.style.background = '#2e3440';
      var editorsElement = document.createElement('div');
      editorsElement.style.width = '100%';
      editorsElement.style.minHeight = '450px';
      editorsElement.style.resize = 'vertical';
      acfInputWrapper.append(editorsElement);
      this.makeEditor(editorsElement, allSettings[this.mode], this.mode);
      this.makeFullScreenModeSwitcher();
    }
  }, {
    key: "initialize",
    value: function initialize() {
      if (!_settings__WEBPACK_IMPORTED_MODULE_1__["default"].hasOwnProperty('mods') || !_settings__WEBPACK_IMPORTED_MODULE_1__["default"]['mods'].hasOwnProperty('_twig') || !_settings__WEBPACK_IMPORTED_MODULE_1__["default"]['mods'].hasOwnProperty('_js') || !_settings__WEBPACK_IMPORTED_MODULE_1__["default"]['mods'].hasOwnProperty('_css') || !_settings__WEBPACK_IMPORTED_MODULE_1__["default"]['mods'].hasOwnProperty('_php')) {
        return;
      }
      if (this.tab.classList.contains('active')) {
        this.make();
        return;
      }
      this.makeCallback = this.make.bind(this);
      // do not listen for 'click', because it is not fired, when switching by ACF (e.g. validation error)
      window['acf'].addAction('show_field/name=' + this.getFieldId(), this.makeCallback);
    }
  }, {
    key: "getFieldId",
    value: function getFieldId() {
      return this.textarea.closest('.acf-field').dataset.key;
    }
  }]);
  return CodeField;
}(_my_element__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CodeField);

/***/ }),

/***/ "./lite/admin/js/cpt-item/field-label-tooltip.ts":
/*!*******************************************************!*\
  !*** ./lite/admin/js/cpt-item/field-label-tooltip.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/core/dist/floating-ui.core.mjs");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

var FieldLabelTooltip = /*#__PURE__*/function () {
  function FieldLabelTooltip() {
    _classCallCheck(this, FieldLabelTooltip);
    this.initialize();
  }
  _createClass(FieldLabelTooltip, [{
    key: "initialize",
    value: function initialize() {
      var _this = this;
      if (!window.hasOwnProperty('MutationObserver')) {
        console.log('AcfViews : MutationObserver doesn\'t supported');
        return '';
      }
      this.addListeners(document.body);
      var observer = new MutationObserver(function (records, observer) {
        var _iterator = _createForOfIteratorHelper(records),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var record = _step.value;
            record.addedNodes.forEach(function (addedNode) {
              _this.addListeners(addedNode);
            });
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    }
  }, {
    key: "maybeShowTooltip",
    value: function maybeShowTooltip(label) {
      // already visible
      if (label.dataset.hasOwnProperty('tooltip')) {
        return;
      }
      label.dataset['tooltip'] = "true";
      var tooltip = document.createElement('div');
      tooltip.classList.add('acf-views__tooltip');
      tooltip.innerHTML = label.nextElementSibling.innerHTML;
      document.body.append(tooltip);
      var hideTimeout = null;
      var hideOnMouseLeave = function hideOnMouseLeave() {
        hideTimeout = setTimeout(removeTooltip, 500);
      };
      var removeTooltip = function removeTooltip() {
        stopTooltipRefresh();
        tooltip.remove();
        delete label.dataset['tooltip'];
        label.removeEventListener('mouseleave', hideOnMouseLeave);
      };
      tooltip.addEventListener('mouseenter', function () {
        if (hideTimeout) {
          clearTimeout(hideTimeout);
        }
        tooltip.addEventListener('mouseleave', removeTooltip);
      });
      var stopTooltipRefresh = (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate)(label, tooltip, function () {
        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(label, tooltip, {
          placement: 'top-start',
          middleware: [(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.offset)(10), (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.flip)(), (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.shift)()]
        }).then(function (_ref) {
          var x = _ref.x,
            y = _ref.y;
          Object.assign(tooltip.style, {
            left: "".concat(x, "px"),
            top: "".concat(y, "px")
          });
        });
      });
      label.addEventListener('mouseleave', hideOnMouseLeave);
    }
  }, {
    key: "addListeners",
    value: function addListeners(element) {
      var _this2 = this;
      if (Node.ELEMENT_NODE !== element.nodeType) {
        return;
      }
      element.querySelectorAll('.acf-field .acf-label label').forEach(function (label) {
        // skip if there are no instructions
        if (!label.nextSibling || !label.nextSibling.classList.contains('description')) {
          return;
        }
        var delayedShowTimeoutId = null;
        label.addEventListener('mouseenter', function () {
          delayedShowTimeoutId = setTimeout(_this2.maybeShowTooltip.bind(_this2, label), 500);
        });
        label.addEventListener('mouseleave', function () {
          if (delayedShowTimeoutId) {
            clearTimeout(delayedShowTimeoutId);
          }
        });
      });
    }
  }]);
  return FieldLabelTooltip;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FieldLabelTooltip);

/***/ }),

/***/ "./lite/admin/js/cpt-item/field-select.ts":
/*!************************************************!*\
  !*** ./lite/admin/js/cpt-item/field-select.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _my_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./my-element */ "./lite/admin/js/cpt-item/my-element.ts");
/* harmony import */ var _jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jquery */ "./lite/admin/js/cpt-item/jquery.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings */ "./lite/admin/js/cpt-item/settings.ts");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var GLOBAL_GROUP_SELECT_ID = 'acf-local_acf_views_view__group';
var GLOBAL_PARENT_FIELD_SELECT_ID = 'acf-local_acf_views_view__parent-field';
var FieldSelect = /*#__PURE__*/function (_MyElement) {
  _inherits(FieldSelect, _MyElement);
  var _super = _createSuper(FieldSelect);
  function FieldSelect(mainSelectId, subSelectId, identifierInputId, isFieldsOnly) {
    var _this;
    var isGlobalSelect = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    _classCallCheck(this, FieldSelect);
    _this = _super.call(this);
    _this.mainSelectId = mainSelectId;
    _this.subSelectId = subSelectId;
    _this.identifierInputId = identifierInputId;
    _this.isFieldsOnly = isFieldsOnly;
    _this.isGlobalSelect = isGlobalSelect;
    _this.globalParentFieldSelect = null;
    return _this;
  }
  _createClass(FieldSelect, [{
    key: "initialize",
    value: function initialize() {
      var _this2 = this;
      if (!window.hasOwnProperty('MutationObserver')) {
        console.log('AcfViews : MutationObserver doesn\'t supported');
        return '';
      }
      this.addListeners(document.body);
      var observer = new MutationObserver(function (records, observer) {
        var _iterator = _createForOfIteratorHelper(records),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var record = _step.value;
            record.addedNodes.forEach(function (addedNode) {
              _this2.addListeners(addedNode);
            });
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    }
  }, {
    key: "addListeners",
    value: function addListeners(element) {
      var _this3 = this;
      if (Node.ELEMENT_NODE !== element.nodeType) {
        return;
      }
      // global means a special case for the 'parent field', so global is already in use 
      var globalGroupSelect = false === this.isGlobalSelect ? document.body.querySelector('select[id="' + GLOBAL_GROUP_SELECT_ID + '"]') : null;
      this.globalParentFieldSelect = false === this.isGlobalSelect ? document.body.querySelector('select[id="' + GLOBAL_PARENT_FIELD_SELECT_ID + '"]') : null;
      var selector = false === this.isGlobalSelect ? 'select[id*="' + this.mainSelectId + '"]' : 'select[id="' + this.mainSelectId + '"]';
      element.querySelectorAll(selector).forEach(function (mainSelect, index) {
        var defaultValue = false === _this3.isFieldsOnly && null !== globalGroupSelect && '' !== globalGroupSelect.value ? globalGroupSelect.value : mainSelect.value;
        _this3.updateAvailableFields(mainSelect, defaultValue);
        // it's necessary to use jQuery.on('change'), because select2 doesn't trigger ordinary JS onChange
        (0,_jquery__WEBPACK_IMPORTED_MODULE_1__["default"])(mainSelect).on('change', function (event) {
          _this3.updateAvailableFields(mainSelect, mainSelect.value, true);
          _this3.generateFieldIdentifierIfPresent(mainSelect);
        });
        if (null !== globalGroupSelect) {
          // it's necessary to use jQuery.on('change'), because select2 doesn't trigger ordinary JS onChange
          (0,_jquery__WEBPACK_IMPORTED_MODULE_1__["default"])(globalGroupSelect).on('change', function (event) {
            (0,_jquery__WEBPACK_IMPORTED_MODULE_1__["default"])(mainSelect).val(globalGroupSelect.value).trigger('change');
          });
        }
        if (null !== _this3.globalParentFieldSelect) {
          // it's necessary to use jQuery.on('change'), because select2 doesn't trigger ordinary JS onChange
          (0,_jquery__WEBPACK_IMPORTED_MODULE_1__["default"])(_this3.globalParentFieldSelect).on('change', function (event) {
            (0,_jquery__WEBPACK_IMPORTED_MODULE_1__["default"])(mainSelect).val(globalGroupSelect.value).trigger('change');
          });
        }
      });
      selector = false === this.isGlobalSelect ? 'select[id*="' + this.subSelectId + '"]' : 'select[id="' + this.subSelectId + '"]';
      element.querySelectorAll(selector).forEach(function (subSelect, index) {
        subSelect.addEventListener('change', function (event) {
          _this3.generateFieldIdentifierIfPresent(event.target);
        });
      });
    }
  }, {
    key: "updateAvailableFields",
    value: function updateAvailableFields(mainSelect, value) {
      var _this4 = this;
      var isChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var box = mainSelect.closest('.acf-row');
      box = !box ? mainSelect.closest('.acf-postbox') : box;
      // filter by the parent field, if it's a 'group + field' relation
      // (skip isFieldsOnly, which means 'field + sub-field' 
      if (false === this.isFieldsOnly && null !== this.globalParentFieldSelect && '' !== this.globalParentFieldSelect.value) {
        value = this.globalParentFieldSelect.value;
      }
      var selector = false === this.isGlobalSelect ? 'select[id*="' + this.subSelectId + '"]' : 'select[id="' + this.subSelectId + '"]';
      box.querySelectorAll(selector).forEach(function (subSelect) {
        if (isChanged) {
          // reset the current option
          subSelect.value = '';
        }
        // filter by groupId, [fieldId]
        var mainSelectIds = value.split('|');
        subSelect.querySelectorAll('option').forEach(function (fieldOption) {
          // always keep default option
          if ('' === fieldOption.value) {
            return;
          }
          var optionIds = fieldOption.value.split('|');
          var isMatch = false;
          // ignore last part (works in all cases: with group/field filters and without them)
          var optionIdsLast = optionIds.length - 1;
          // for global select (group + parent field) - filter any match, regardless of the hierarchy
          // for others: filter only items with the same level of hierarchy 
          if (true === _this4.isGlobalSelect) {
            isMatch = fieldOption.value.startsWith(value);
          } else if (optionIdsLast === mainSelectIds.length) {
            isMatch = true;
            for (var i = 0; i < optionIdsLast; i++) {
              if (i < mainSelectIds.length && optionIds[i] === mainSelectIds[i]) {
                continue;
              }
              isMatch = false;
              break;
            }
          }
          if (false === isMatch) {
            fieldOption.style.display = 'none';
            return;
          }
          fieldOption.style.display = '';
        });
        if (isChanged) {
          // important for repeater fields select
          subSelect.dispatchEvent(new Event('change'));
        }
      });
    }
  }, {
    key: "getUniqueIdWithinScope",
    value: function getUniqueIdWithinScope(scope, id) {
      var currentIds = [];
      // it can be either a main field or a repeater field
      var fields = [].concat(_toConsumableArray(scope.querySelectorAll('.acf-field[data-key=local_acf_views_field__id]')), _toConsumableArray(scope.querySelectorAll('.acf-field[data-key=local_acf_views_repeater-field__id]')));
      fields.forEach(function (field) {
        currentIds.push(field.querySelector('input').value);
      });
      if (-1 === currentIds.indexOf(id)) {
        return id;
      }
      return this.getUniqueIdWithinScope(scope, id + '2');
    }
  }, {
    key: "getFieldLabelInEnglish",
    value: function getFieldLabelInEnglish(chosenFieldKey) {
      if (false === _settings__WEBPACK_IMPORTED_MODULE_2__["default"].hasOwnProperty('allFieldChoicesInEnglish') || false === _settings__WEBPACK_IMPORTED_MODULE_2__["default"].allFieldChoicesInEnglish.hasOwnProperty(chosenFieldKey)) {
        console.log('Advanced Views: allFieldChoicesInEnglish property is missing');
        return 'field';
      }
      return _settings__WEBPACK_IMPORTED_MODULE_2__["default"].allFieldChoicesInEnglish[chosenFieldKey];
    }
  }, {
    key: "generateFieldIdentifierIfPresent",
    value: function generateFieldIdentifierIfPresent(rowSelect) {
      // optional
      if ('' === this.identifierInputId) {
        return;
      }
      var row = rowSelect.closest('.acf-row');
      // can be not present (on the Card Basic tab)
      if (!row) {
        return;
      }
      var identifierInput = row.querySelector('input[id*="' + this.identifierInputId + '"]');
      // can be not present (on the Card Meta Filters tab)
      if (!identifierInput) {
        return;
      }
      var chosenOption = rowSelect.querySelector('select[id*="' + this.subSelectId + '"] option:checked');
      // element can be missing, as nothing can be chosen in the 'select'
      if (!chosenOption) {
        identifierInput.value = '';
        return;
      }
      // 'Field (type) to 'Field' - remove the type, but only the last brackets.
      var chosenField = this.getFieldLabelInEnglish(chosenOption.value);
      chosenField = chosenField.replace(/ \([^)]+\)$/, '');
      // 'Some field name' to 'some-field-name'
      var id = chosenField.toLowerCase().replace(/ /g, '-');
      // 'some_field' to 'some-field', as dash is welcomed by BEM
      id = id.replace(/_/g, '-');
      // remove all other characters
      id = id.replace(/[^a-z0-9\-]/g, '');
      // make sure that the field is unique across the whole View
      // (not within the current repeater,
      // because FrontAssets expect fully unique field ids for the CSS auto-discover generation)
      identifierInput.value = this.getUniqueIdWithinScope(document.body, id);
    }
  }]);
  return FieldSelect;
}(_my_element__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FieldSelect);

/***/ }),

/***/ "./lite/admin/js/cpt-item/fields-changed-notice.ts":
/*!*********************************************************!*\
  !*** ./lite/admin/js/cpt-item/fields-changed-notice.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var FieldsChangedNotice = /*#__PURE__*/function () {
  function FieldsChangedNotice() {
    _classCallCheck(this, FieldsChangedNotice);
    this.changedInputs = [];
    this.initialFieldValues = {};
    this.highlightedTabs = {};
    this.isWithRemovedRows = false;
    this.setup();
  }
  _createClass(FieldsChangedNotice, [{
    key: "getCurrentFieldValue",
    value: function getCurrentFieldValue(input) {
      var isCheckbox = 'checkbox' === input.type;
      var isMultipleSelect = input.dataset.hasOwnProperty('multiple') && '1' === input.dataset.multiple;
      var value = input.value;
      value = isCheckbox ? input.checked : value;
      value = isMultipleSelect ? Array.from(input.querySelectorAll("option:checked"), function (e) {
        return e.value;
      }).toString() : value;
      return value;
    }
  }, {
    key: "setInitialFieldValue",
    value: function setInitialFieldValue(input) {
      this.initialFieldValues[input.name] = this.getCurrentFieldValue(input);
    }
  }, {
    key: "changeTabAmendedInputsNumber",
    value: function changeTabAmendedInputsNumber(field, isChanged) {
      var tabField = field;
      while (tabField && !tabField.classList.contains('acf-field-tab')) {
        tabField = tabField.previousElementSibling;
      }
      if (!tabField) {
        console.log({
          field: field
        });
        new Error('Tab field not found');
        return;
      }
      var tabKey = tabField.dataset.key;
      var tabWrap = tabField;
      while (tabWrap && !tabWrap.classList.contains('acf-tab-wrap')) {
        tabWrap = tabWrap.previousElementSibling;
      }
      var tabMenuItem = tabWrap.querySelector('.acf-tab-button[data-key="' + tabKey + '"]');
      var amendedInputsNumber = tabMenuItem.dataset.hasOwnProperty('amendedInputsNumber') ? parseInt(tabMenuItem.dataset.amendedInputsNumber) : 0;
      if (isChanged) {
        amendedInputsNumber++;
      } else {
        amendedInputsNumber--;
      }
      if (!amendedInputsNumber) {
        delete tabMenuItem.dataset.amendedInputsNumber;
        return;
      }
      tabMenuItem.dataset.amendedInputsNumber = amendedInputsNumber.toString();
    }
  }, {
    key: "changeTabsAmendedInputsNumber",
    value: function changeTabsAmendedInputsNumber(input, isChanged) {
      var field = input.closest('.acf-field');
      this.changeTabAmendedInputsNumber(field, isChanged);
      var parentField = field.parentElement.closest('.acf-field');
      while (parentField) {
        this.changeTabAmendedInputsNumber(parentField, isChanged);
        parentField = parentField.parentElement.closest('.acf-field');
      }
    }
  }, {
    key: "toggleInputState",
    value: function toggleInputState(event) {
      var input = event.target;
      // ignore automatic refresh changed (after save)
      if (input.dataset.hasOwnProperty('acfViewsRefresh')) {
        this.setInitialFieldValue(input);
        return;
      }
      var currentValue = this.getCurrentFieldValue(input);
      var isChanged = this.initialFieldValues[input.name] !== currentValue;
      var indexInList = this.changedInputs.indexOf(input);
      if (isChanged) {
        if (-1 === indexInList) {
          this.changedInputs.push(input);
          this.changeTabsAmendedInputsNumber(input, isChanged);
        }
        return;
      }
      if (-1 === indexInList) {
        return;
      }
      this.changedInputs.splice(indexInList, 1);
      this.changeTabsAmendedInputsNumber(input, isChanged);
    }
  }, {
    key: "watchInput",
    value: function watchInput(input) {
      var isSelect = 'select' === input.tagName.toLowerCase();
      this.setInitialFieldValue(input);
      if (!isSelect) {
        input.addEventListener('change', this.toggleInputState.bind(this));
      } else {
        // it's necessary to use jQuery.on('change'), because select2 doesn't trigger ordinary JS onChange
        window['jQuery'](input).on('change', this.toggleInputState.bind(this));
      }
    }
  }, {
    key: "getInputSelectors",
    value: function getInputSelectors() {
      return '.acf-field .acf-input input' + ', .acf-field .acf-input textarea' + ', .acf-field .acf-input select';
    }
  }, {
    key: "addListeners",
    value: function addListeners(element) {
      var _this = this;
      if (Node.ELEMENT_NODE !== element.nodeType) {
        return;
      }
      var inputSelectors = this.getInputSelectors();
      element.querySelectorAll(inputSelectors).forEach(function (input) {
        // ignore disabled inputs (like "Template Preview")
        if (input.hasAttribute('disabled')) {
          return;
        }
        _this.watchInput(input);
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this2 = this;
      this.isWithRemovedRows = false;
      this.changedInputs.forEach(function (input) {
        _this2.setInitialFieldValue(input);
        _this2.changeTabsAmendedInputsNumber(input, false);
      });
      this.changedInputs = [];
      for (var tabKey in this.highlightedTabs) {
        var tabMenuItem = document.querySelector('.acf-tab-button[data-key="' + tabKey + '"]');
        tabMenuItem.classList.remove('acf-views--changed');
      }
      this.highlightedTabs = {};
    }
  }, {
    key: "setup",
    value: function setup() {
      var _this3 = this;
      if (!window.hasOwnProperty('MutationObserver')) {
        console.log('AcfViews : MutationObserver doesn\'t supported');
        return '';
      }
      this.addListeners(document.body);
      var observer = new MutationObserver(function (records, observer) {
        var _iterator = _createForOfIteratorHelper(records),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var record = _step.value;
            record.addedNodes.forEach(function (addedNode) {
              _this3.addListeners(addedNode);
            });
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      window.addEventListener('beforeunload', function (event) {
        if (!_this3.changedInputs.length && !_this3.isWithRemovedRows) {
          return;
        }
        event.preventDefault();
        event.returnValue = '';
      });
      document.body.addEventListener('_acf-views-refresh-ajax', this.reset.bind(this));
      window['acf'].addAction('remove_field', function () {
        _this3.isWithRemovedRows = true;
      });
    }
  }]);
  return FieldsChangedNotice;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FieldsChangedNotice);

/***/ }),

/***/ "./lite/admin/js/cpt-item/jquery.ts":
/*!******************************************!*\
  !*** ./lite/admin/js/cpt-item/jquery.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// jquery is necessary for select2 events
var jQuery = window.hasOwnProperty('jQuery') ? window['jQuery'] : null;
if (!jQuery) {
  new Error('JQuery is missing');
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (jQuery);

/***/ }),

/***/ "./lite/admin/js/cpt-item/my-element.ts":
/*!**********************************************!*\
  !*** ./lite/admin/js/cpt-item/my-element.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var MyElement = /*#__PURE__*/function () {
  function MyElement() {
    var _this = this;
    var isOnReady = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    _classCallCheck(this, MyElement);
    // allow to initialize child class fields
    setTimeout(function () {
      var callback = _this.initialize.bind(_this);
      isOnReady ? MyElement.addDocumentReadyListener(callback) : MyElement.addWindowLoadListener(callback);
    }, 0);
  }
  _createClass(MyElement, [{
    key: "initialize",
    value: function initialize() {}
  }], [{
    key: "addDocumentReadyListener",
    value: function addDocumentReadyListener(callback) {
      'loading' !== document.readyState ? callback() : window.addEventListener('DOMContentLoaded', callback);
    }
  }, {
    key: "addWindowLoadListener",
    value: function addWindowLoadListener(callback) {
      'complete' !== document.readyState ? window.addEventListener('load', callback) : callback();
    }
  }]);
  return MyElement;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MyElement);

/***/ }),

/***/ "./lite/admin/js/cpt-item/postbox.ts":
/*!*******************************************!*\
  !*** ./lite/admin/js/cpt-item/postbox.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _my_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./my-element */ "./lite/admin/js/cpt-item/my-element.ts");
/* harmony import */ var _field_select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./field-select */ "./lite/admin/js/cpt-item/field-select.ts");
/* harmony import */ var _code_field__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./code-field */ "./lite/admin/js/cpt-item/code-field.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings */ "./lite/admin/js/cpt-item/settings.ts");
/* harmony import */ var _field_label_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./field-label-tooltip */ "./lite/admin/js/cpt-item/field-label-tooltip.ts");
/* harmony import */ var _fields_changed_notice__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fields-changed-notice */ "./lite/admin/js/cpt-item/fields-changed-notice.ts");
/* harmony import */ var _variable_auto_complete__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./variable-auto-complete */ "./lite/admin/js/cpt-item/variable-auto-complete.ts");
/* harmony import */ var _refresh_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./refresh-request */ "./lite/admin/js/cpt-item/refresh-request.ts");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }








var PostBox = /*#__PURE__*/function (_MyElement) {
  _inherits(PostBox, _MyElement);
  var _super = _createSuper(PostBox);
  function PostBox() {
    var _this;
    _classCallCheck(this, PostBox);
    _this = _super.call(this);
    _this.codeFields = [];
    _this.variableAutoCompleter = null;
    _this.editorWithVariableAutocomplete = null;
    return _this;
  }
  _createClass(PostBox, [{
    key: "createCodeFields",
    value: function createCodeFields() {
      var _this2 = this;
      if (!_settings__WEBPACK_IMPORTED_MODULE_3__["default"].hasOwnProperty('markupTextarea')) {
        new Error('Required argument is missing');
      }
      _settings__WEBPACK_IMPORTED_MODULE_3__["default"]['markupTextarea'].forEach(function (markupTextarea) {
        if (!markupTextarea.hasOwnProperty('idSelector') || !markupTextarea.hasOwnProperty('isWithVariableAutocomplete') || !markupTextarea.hasOwnProperty('mode') || !markupTextarea.hasOwnProperty('isReadOnly') || !markupTextarea.hasOwnProperty('linkTitle') || !markupTextarea.hasOwnProperty('tabIdSelector')) {
          new Error('Required argument is missing');
        }
        var textarea = document.body.querySelector('textarea[id*="' + markupTextarea.idSelector + '"]');
        // optionally, as the field list contains fields from 2 pages
        if (!textarea) {
          return;
        }
        var tab = document.body.querySelector('.acf-tab-button[data-key="' + markupTextarea.tabIdSelector + '"]').parentElement;
        var codeField = new _code_field__WEBPACK_IMPORTED_MODULE_2__["default"](_this2, tab, textarea, markupTextarea.mode, markupTextarea.isReadOnly, markupTextarea.linkTitle, markupTextarea.isWithVariableAutocomplete);
        _this2.codeFields[codeField.getFieldId()] = codeField;
      });
    }
  }, {
    key: "createFieldSelects",
    value: function createFieldSelects() {
      if (!_settings__WEBPACK_IMPORTED_MODULE_3__["default"].hasOwnProperty('fieldSelect')) {
        new Error('Required property is missing');
      }
      _settings__WEBPACK_IMPORTED_MODULE_3__["default"].fieldSelect.forEach(function (fieldSelect) {
        if (!fieldSelect.hasOwnProperty('mainSelectId') || !fieldSelect.hasOwnProperty('subSelectId') || !fieldSelect.hasOwnProperty('identifierInputId')) {
          new Error('Required property is missing');
        }
        var isFieldsOnly = true === fieldSelect.hasOwnProperty('isFieldsOnly') && true === fieldSelect['isFieldsOnly'];
        new _field_select__WEBPACK_IMPORTED_MODULE_1__["default"](fieldSelect.mainSelectId, fieldSelect.subSelectId, fieldSelect.identifierInputId, isFieldsOnly);
      });
    }
    /*
    * Suppress the default fullscreen mode
    * (when users install the plugin first time, they'll see the fullscreen mode for View & Card CPTs)
    * we should avoid this. In addition, even if users enable the fullscreen mode, it should be kept among reloads
     */
  }, {
    key: "suppressDefaultFullscreenMode",
    value: function suppressDefaultFullscreenMode() {
      var wpData = window['wp'].data;
      var isFullScreen = wpData.select('core/edit-post').isFeatureActive('fullscreenMode');
      if (!isFullScreen) {
        return;
      }
      wpData.dispatch('core/edit-post').toggleFeature('fullscreenMode');
    }
  }, {
    key: "suppressAcfTabsRemembering",
    value: function suppressAcfTabsRemembering() {
      window.addEventListener('beforeunload', function (event) {
        var acf = window['acf'];
        acf.setPreference('tabs-' + acf.get('post_id'), null);
      });
    }
  }, {
    key: "setupRefreshAjax",
    value: function setupRefreshAjax() {
      var refreshRoute = _settings__WEBPACK_IMPORTED_MODULE_3__["default"].hasOwnProperty('refreshRoute') ? _settings__WEBPACK_IMPORTED_MODULE_3__["default"].refreshRoute : '';
      var refreshNonce = _settings__WEBPACK_IMPORTED_MODULE_3__["default"].hasOwnProperty('refreshNonce') ? _settings__WEBPACK_IMPORTED_MODULE_3__["default"].refreshNonce : '';
      var textareaItemsToRefresh = _settings__WEBPACK_IMPORTED_MODULE_3__["default"].hasOwnProperty('textareaItemsToRefresh') ? _settings__WEBPACK_IMPORTED_MODULE_3__["default"].textareaItemsToRefresh : [];
      var textareaItems = [];
      textareaItemsToRefresh.forEach(function (textareaItemId) {
        var textarea = document.querySelector('#' + textareaItemId);
        if (!textarea) {
          return;
        }
        textareaItems.push(textarea);
      });
      if (textareaItems.length !== textareaItemsToRefresh.length || !refreshRoute || !refreshNonce) {
        console.log('refresh data', {
          refreshRoute: refreshRoute,
          refreshNonce: refreshNonce,
          textareaItemsToRefresh: textareaItemsToRefresh
        });
        new Error('Fail to setup refresh request');
      }
      new _refresh_request__WEBPACK_IMPORTED_MODULE_7__["default"](this, textareaItems, refreshRoute, refreshNonce);
    }
  }, {
    key: "init",
    value: function init() {
      this.suppressDefaultFullscreenMode();
      this.createFieldSelects();
      this.createCodeFields();
      new _field_label_tooltip__WEBPACK_IMPORTED_MODULE_4__["default"]();
      this.suppressAcfTabsRemembering();
      new _fields_changed_notice__WEBPACK_IMPORTED_MODULE_5__["default"]();
      this.variableAutoCompleter = new _variable_auto_complete__WEBPACK_IMPORTED_MODULE_6__["default"]();
      this.setupRefreshAjax();
    }
  }, {
    key: "getCodeFields",
    value: function getCodeFields() {
      return Object.values(this.codeFields);
    }
  }, {
    key: "getCodeFieldById",
    value: function getCodeFieldById(id) {
      return this.codeFields[id];
    }
  }, {
    key: "getCompletions",
    value: function getCompletions(editor, session, pos, prefix, callback) {
      if (this.editorWithVariableAutocomplete !== editor) {
        return;
      }
      this.variableAutoCompleter.getCompletions(editor, session, pos, prefix, callback);
    }
  }, {
    key: "updateAutocompleteData",
    value: function updateAutocompleteData(autocompleteData) {
      this.variableAutoCompleter.updateAutocompleteData(autocompleteData);
    }
  }, {
    key: "setEditorWithVariableAutocomplete",
    value: function setEditorWithVariableAutocomplete(editor) {
      this.editorWithVariableAutocomplete = editor;
    }
  }]);
  return PostBox;
}(_my_element__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PostBox);

/***/ }),

/***/ "./lite/admin/js/cpt-item/preview.ts":
/*!*******************************************!*\
  !*** ./lite/admin/js/cpt-item/preview.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Preview = /*#__PURE__*/function () {
  function Preview(tabSelector, previewFieldSelector, html, css, homeUrl) {
    var extraCss = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
    _classCallCheck(this, Preview);
    this.tab = document.body.querySelector(tabSelector).parentElement;
    this.previewField = document.querySelector(previewFieldSelector);
    this.html = html;
    this.css = css;
    this.homeUrl = homeUrl;
    this.extraCss = extraCss;
  }
  _createClass(Preview, [{
    key: "initialize",
    value: function initialize() {
      var _this = this;
      if (this.tab.classList.contains('active')) {
        this.makeAjax();
        return;
      }
      var isInit = false;
      this.tab.addEventListener('click', function (event) {
        if (isInit) {
          return;
        }
        isInit = true;
        _this.makeAjax();
      });
    }
  }, {
    key: "makeAjax",
    value: function makeAjax() {
      var _this2 = this;
      var request = new XMLHttpRequest();
      request.timeout = 30000;
      request.open('GET', this.homeUrl, true);
      request.addEventListener('readystatechange', function () {
        if (request.readyState !== 4) {
          return;
        }
        if (200 !== request.status) {
          console.log('preview : ajax request is failed');
          return;
        }
        _this2.grepStyles(request.responseText);
      });
      request.addEventListener('timeout', function () {
        console.log('preview : ajax timeout');
      });
      request.send();
    }
  }, {
    key: "grepStyles",
    value: function grepStyles(pageHtml) {
      var html = document.createElement('div');
      html.innerHTML = pageHtml;
      var stylesheets = [];
      var styles = '';
      html.querySelectorAll('link[rel=stylesheet]').forEach(function (stylesheet) {
        stylesheets.push(stylesheet.href);
      });
      html.querySelectorAll('style').forEach(function (style) {
        styles += style.outerHTML;
      });
      this.createFiddle(stylesheets, styles);
    }
    // https://blog.codepen.io/documentation/prefill-embeds/
  }, {
    key: "createFiddle",
    value: function createFiddle(stylesheets, styles) {
      var fiddle = document.createElement('div');
      var fiddleScript = document.createElement('script');
      var html = document.createElement('pre');
      var css = document.createElement('pre');
      fiddle.classList.add('codepen');
      // encodeURI is necessary in case using of 'head'
      fiddle.dataset['prefill'] = encodeURI(JSON.stringify({
        stylesheets: stylesheets,
        // some padding to body, to give better look + extraCss (e.g. viewCss for card)
        head: styles + '<style>body{padding:20px;}' + this.extraCss + '</style>'
      }));
      fiddle.dataset['editable'] = 'true';
      fiddle.dataset['height'] = '800';
      fiddle.dataset['defaultTab'] = 'result';
      fiddleScript.setAttribute('async', 'on');
      fiddleScript.setAttribute('src', 'https://static.codepen.io/assets/embed/ei.js');
      html.dataset['lang'] = 'html';
      html.innerHTML = this.html;
      css.dataset['lang'] = 'css';
      css.innerHTML = this.css ? this.css : '/*todo : test your styles here, then copy to the "CSS Code" field and press the "Update" button */';
      fiddle.appendChild(html);
      fiddle.appendChild(css);
      fiddle.append(fiddleScript);
      this.previewField.replaceWith(fiddle);
    }
  }]);
  return Preview;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Preview);

/***/ }),

/***/ "./lite/admin/js/cpt-item/refresh-request.ts":
/*!***************************************************!*\
  !*** ./lite/admin/js/cpt-item/refresh-request.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings */ "./lite/admin/js/cpt-item/settings.ts");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

var RefreshRequest = /*#__PURE__*/function () {
  function RefreshRequest(postBox, textareas, refreshRoute, refreshNonce) {
    _classCallCheck(this, RefreshRequest);
    this.postBox = postBox;
    this.textareas = textareas;
    this.refreshRoute = refreshRoute;
    this.refreshNonce = refreshNonce;
    this.isSent = false;
    this.wpData = null;
    'loading' !== document.readyState ? this.init() : document.addEventListener('DOMContentLoaded', this.init.bind(this));
  }
  _createClass(RefreshRequest, [{
    key: "reload",
    value: function reload(acfFields, data) {
      var _this = this;
      if (!data.hasOwnProperty('textareaItems') || !data.hasOwnProperty('elements') || !data.hasOwnProperty('autocompleteData')) {
        console.log('ajax response', data);
        new Error('Ajax response is wrong');
        return;
      }
      Object.keys(data['textareaItems']).forEach(function (textareaId) {
        var targetTextareaItems = _this.textareas.filter(function (textarea) {
          return textarea.id === textareaId;
        });
        var textarea = targetTextareaItems.length > 0 ? targetTextareaItems[0] : null;
        if (!textarea) {
          console.log('textarea to refresh', textareaId);
          new Error('Textarea to refresh is missing');
          return;
        }
        textarea.value = data['textareaItems'][textareaId];
        textarea.dataset.acfViewsRefresh = '1';
        textarea.dispatchEvent(new Event('change'));
        delete textarea.dataset.acfViewsRefresh;
      });
      acfFields.forEach(function (acfField) {
        acfField.classList.remove('_reloading');
      });
      // always update all the elements, including the shortcode
      // not only once, because the shortcode can be changed
      // (on the New Post page, if during publishing were errors, then we won't see the shortcode yet)
      Object.keys(data['elements']).forEach(function (selector) {
        document.querySelector(selector).innerHTML = data['elements'][selector];
      });
      this.postBox.updateAutocompleteData(data['autocompleteData']);
    }
  }, {
    key: "makeRequest",
    value: function makeRequest() {
      var _this2 = this;
      var acfFields = [];
      this.textareas.forEach(function (textarea) {
        acfFields.push(textarea.closest('.acf-field'));
      });
      acfFields.forEach(function (acfField) {
        acfField.classList.add('_reloading');
      });
      var requestArgs = {
        _postId: this.wpData.select('core/editor').getCurrentPostId(),
        _noCache: new Date().getTime().toString()
      };
      fetch('/wp-json/acf_views/v1' + this.refreshRoute, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-WP-Nonce': this.refreshNonce
        },
        body: JSON.stringify(requestArgs)
      }).then(function (response) {
        return response.json();
      }).then(function (response) {
        _this2.reload(acfFields, response);
      })["catch"](function (error) {
        return function () {
          console.log('AVF: Refresh request error', error);
          throw new Error('AVF: Refresh request error');
        };
      });
    }
    // built-in 'post updated' notification is showed right after the main post data is saved
    // it's too early. Manually delay to the moment when the postboxes are saved
  }, {
    key: "switchOnUpdatedNotification",
    value: function switchOnUpdatedNotification() {
      var notifications = document.querySelector('.components-editor-notices__snackbar');
      notifications.style.opacity = '1';
      setTimeout(function () {
        // hidden in CSS
        notifications.style.opacity = '';
      }, 5000);
    }
  }, {
    key: "maybeTriggerSaved",
    value: function maybeTriggerSaved() {
      var isSavingPost = this.wpData.select('core/editor').isSavingPost();
      var isSavingMetaBoxes = this.wpData.select('core/edit-post').isSavingMetaBoxes();
      // on wordpress.com hosting we must wait the meta boxes to be saved (as acf ajax validation doesn't work there)
      var isSavingFlag = _settings__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty('isWordpressComHosting') && _settings__WEBPACK_IMPORTED_MODULE_0__["default"]['isWordpressComHosting'] ? isSavingMetaBoxes : isSavingPost;
      if (isSavingFlag && !this.isSent) {
        this.isSent = true;
        return;
      }
      if (!isSavingFlag && this.isSent) {
        this.isSent = false;
        this.switchOnUpdatedNotification();
        this.makeRequest();
        document.body.dispatchEvent(new Event('_acf-views-refresh-ajax'));
      }
    }
  }, {
    key: "init",
    value: function init() {
      this.wpData = window['wp'].data;
      this.wpData.subscribe(this.maybeTriggerSaved.bind(this));
    }
  }]);
  return RefreshRequest;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RefreshRequest);

/***/ }),

/***/ "./lite/admin/js/cpt-item/request-blocker.ts":
/*!***************************************************!*\
  !*** ./lite/admin/js/cpt-item/request-blocker.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings */ "./lite/admin/js/cpt-item/settings.ts");
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

// 1. What is it?
// the code below blocks unused ajax requests (like wp-json/?taxonomies, blocks and others)
// it should reduce unnecessary network load and improve performance
// 2. How it works?
// below is overriding the default wp.apiFetch handler
// to ignore unnecessary requests and improve performance
// see for details wp-includes/js/dist/api-fetch.js
// 3. What requests are needed?
// we need only these:
// 1. admin-ajax.php : acf validation, wp heartbeat, our ajax.
// 2. post.php: metaboxes update (acf groups)
// 3. /acf_views/ or /acf_cards/ (/wp-json/wp/v2/{name}/{id}?_locale=user) post title and status updates
var DEFAULT_HEADERS = {
  // The backend uses the Accept header as a condition for considering an
  // incoming request as a REST request.
  //
  // See: https://core.trac.wordpress.org/ticket/44534
  Accept: 'application/json, */*;q=0.1'
};
/**
 * Default set of fetch option values which should be sent with every request
 * unless explicitly provided through apiFetch options.
 *
 * @type {Object}
 */
var DEFAULT_OPTIONS = {
  credentials: 'include'
};
var checkStatus = function checkStatus(response) {
  if (response.status >= 200 && response.status < 300) {
    return response;
  }
  throw response;
};
var parseResponseAndNormalizeError = function parseResponseAndNormalizeError(response) {
  var shouldParseResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return Promise.resolve(response_parseResponse(response, shouldParseResponse))["catch"](function (res) {
    return parseAndThrowError(res, shouldParseResponse);
  });
};
var response_parseResponse = function response_parseResponse(response) {
  var shouldParseResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (shouldParseResponse) {
    if (response.status === 204) {
      return null;
    }
    return response.json ? response.json() : Promise.reject(response);
  }
  return response;
};
var parseJsonAndNormalizeError = function parseJsonAndNormalizeError(response) {
  var invalidJsonError = {
    code: 'invalid_json',
    message: (0, external_wp_i18n_namespaceObject.__)('The response is not a valid JSON response.')
  };
  if (!response || !response.json) {
    throw invalidJsonError;
  }
  return response.json()["catch"](function () {
    throw invalidJsonError;
  });
};
var external_wp_i18n_namespaceObject = window["wp"]["i18n"];
function parseAndThrowError(response) {
  var shouldParseResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (!shouldParseResponse) {
    throw response;
  }
  return parseJsonAndNormalizeError(response).then(function (error) {
    var unknownError = {
      code: 'unknown_error',
      message: (0, external_wp_i18n_namespaceObject.__)('An unknown error occurred.')
    };
    throw error || unknownError;
  });
}
window['wp'].apiFetch.setFetchHandler(function (nextOptions) {
  var url = nextOptions.url,
    path = nextOptions.path,
    data = nextOptions.data,
    _nextOptions$parse = nextOptions.parse,
    parse = _nextOptions$parse === void 0 ? true : _nextOptions$parse,
    remainingOptions = __rest(nextOptions, ["url", "path", "data", "parse"]);
  var body = nextOptions.body,
    headers = nextOptions.headers; // Merge explicitly-provided headers with default values.
  var isPost = -1 !== url.indexOf('post.php');
  var isPostBox = -1 !== url.indexOf('&meta-box-loader=1');
  var isAdminAjax = -1 !== url.indexOf('admin-ajax.php');
  var isAcfViews = -1 !== url.indexOf('/acf_views/');
  var isAcfCards = -1 !== url.indexOf('/acf_cards/');
  var isWordpressComHosting = _settings__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty('isWordpressComHosting') && _settings__WEBPACK_IMPORTED_MODULE_0__["default"]['isWordpressComHosting'];
  // acf ajax validation doesn't work on wordpress.com hosting. So saving is plain, and we should allow the postbox request
  var isPostboxRequest = isPost && isPostBox && !isWordpressComHosting;
  var isPostboxRequestRequired = _settings__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty('isPostboxRequestRequired') && _settings__WEBPACK_IMPORTED_MODULE_0__["default"]['isPostboxRequestRequired'];
  if ((false === isPost || true === isPostboxRequest) && false === isAdminAjax && false === isPostboxRequestRequired && false === isAcfViews && false === isAcfCards) {
    console.log('Advanced Views suppressed: ', url);
    return [];
  }
  headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers); // The `data` property is a shorthand for sending a JSON body.
  if (data) {
    body = JSON.stringify(data);
    headers['Content-Type'] = 'application/json';
  }
  var responsePromise = window.fetch(
  // Fall back to explicitly passing `window.location` which is the behavior if `undefined` is passed.
  url || path || window.location.href, Object.assign(Object.assign(Object.assign({}, DEFAULT_OPTIONS), remainingOptions), {
    body: body,
    headers: headers
  }));
  return responsePromise.then(function (value) {
    return Promise.resolve(value).then(checkStatus)["catch"](function (response) {
      return parseAndThrowError(response, parse);
    }).then(function (response) {
      return parseResponseAndNormalizeError(response, parse);
    });
  }, function (err) {
    // Re-throw AbortError for the users to handle it themselves.
    if (err && err.name === 'AbortError') {
      throw err;
    } // Otherwise, there is most likely no network connection.
    // Unfortunately the message might depend on the browser.
    throw {
      code: 'fetch_error',
      message: (0, external_wp_i18n_namespaceObject.__)('You are probably offline.')
    };
  });
});

/***/ }),

/***/ "./lite/admin/js/cpt-item/settings.ts":
/*!********************************************!*\
  !*** ./lite/admin/js/cpt-item/settings.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ACF_VIEWS = window.hasOwnProperty('acf_views') ? window['acf_views'] : null;
if (!ACF_VIEWS) {
  new Error('Arguments are missing');
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ACF_VIEWS);

/***/ }),

/***/ "./lite/admin/js/cpt-item/shortcodes.ts":
/*!**********************************************!*\
  !*** ./lite/admin/js/cpt-item/shortcodes.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _web_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./web-component */ "./lite/admin/js/cpt-item/web-component.ts");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Shortcodes = /*#__PURE__*/function (_WebComponent) {
  _inherits(Shortcodes, _WebComponent);
  var _super = _createSuper(Shortcodes);
  function Shortcodes() {
    _classCallCheck(this, Shortcodes);
    return _super.apply(this, arguments);
  }
  _createClass(Shortcodes, [{
    key: "tryToClipboardOnHTTP",
    value: function tryToClipboardOnHTTP(element, text) {
      var textarea = document.createElement('textarea');
      textarea.value = text;
      var parent = element.parentElement;
      // exactly as sibling of the target element, because browser will scroll to this element on focus
      parent.insertBefore(textarea, element);
      textarea.focus();
      textarea.select();
      try {
        document.execCommand('copy');
      } catch (err) {
        // nothing
      }
      textarea.remove();
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var _this = this;
      this.querySelectorAll('.av-shortcodes__copy-button').forEach(function (button) {
        button.addEventListener('click', function (event) {
          event.preventDefault();
          var dataTarget = button.getAttribute('data-target');
          if (!dataTarget) {
            new Error('Attribute is missing');
          }
          var target = _this.querySelector(dataTarget);
          if (!target) {
            new Error('Target element is missing');
          }
          // navigator.clipboard works only with HTTPS
          if (window.isSecureContext && navigator.clipboard) {
            navigator.clipboard.writeText(target.textContent);
          } else {
            _this.tryToClipboardOnHTTP(button, target.textContent);
          }
          button.textContent = 'Copied!';
          setTimeout(function () {
            button.textContent = 'Copy to clipboard';
          }, 5000);
        });
      });
    }
  }]);
  return Shortcodes;
}(_web_component__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Shortcodes);

/***/ }),

/***/ "./lite/admin/js/cpt-item/variable-auto-complete.ts":
/*!**********************************************************!*\
  !*** ./lite/admin/js/cpt-item/variable-auto-complete.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings */ "./lite/admin/js/cpt-item/settings.ts");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

var VariableAutoCompleter = /*#__PURE__*/function () {
  function VariableAutoCompleter() {
    _classCallCheck(this, VariableAutoCompleter);
    this.autocompleteVariables = _settings__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty('autocompleteVariables') ? _settings__WEBPACK_IMPORTED_MODULE_0__["default"]['autocompleteVariables'] : {};
    this.autocompleteFunctions = _settings__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty('autocompleteFunctions') ? _settings__WEBPACK_IMPORTED_MODULE_0__["default"]['autocompleteFunctions'] : {};
    this.autocompleteFilters = _settings__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty('autocompleteFilters') ? _settings__WEBPACK_IMPORTED_MODULE_0__["default"]['autocompleteFilters'] : {};
  }
  _createClass(VariableAutoCompleter, [{
    key: "isTwigLine",
    value: function isTwigLine(line) {
      // check only for opening, as the line is likely incomplete yet
      return -1 !== line.indexOf('{{') || -1 !== line.indexOf('{%');
    }
  }, {
    key: "makeAutocompleteItem",
    value: function makeAutocompleteItem(variableName, variableValue, score) {
      var customType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var customCaption = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
      var meta = customType;
      var item = {
        caption: customCaption || variableName,
        value: variableName,
        score: score
      };
      if ('' === meta) {
        if (variableValue instanceof Array) {
          item.meta = 'array';
        } else if (typeof variableValue === 'string') {
          item.meta = 'variable';
        } else {
          item.meta = 'object';
        }
      } else if (null !== meta) {
        item.meta = meta;
      }
      return item;
    }
  }, {
    key: "getContextVariablesAutocomplete",
    value: function getContextVariablesAutocomplete(nameParts, isGlobalVar) {
      var variables = this.autocompleteVariables;
      if (!isGlobalVar) {
        nameParts.forEach(function (namePart) {
          variables = variables[namePart] || {};
        });
      }
      var variablesInfo = [];
      for (var variableName in variables) {
        variablesInfo.push(this.makeAutocompleteItem(variableName, variables[variableName], 1000));
      }
      return variablesInfo;
    }
  }, {
    key: "getCurrentLoops",
    value: function getCurrentLoops(lineNumber, session) {
      var loopsData = [];
      var closedLoops = 0;
      // begin from the previous line
      for (var line = lineNumber - 1; line > 0; line--) {
        var lineText = session.getLine(line);
        // we should ignore loops that are closed before the current line
        if (-1 !== lineText.indexOf('{% endfor')) {
          closedLoops++;
          continue;
        }
        if (-1 === lineText.indexOf('{% for')) {
          continue;
        }
        // we should ignore loops that are closed before the current line
        if (closedLoops) {
          closedLoops--;
          continue;
        }
        var loopData = lineText.match(/{%[ ]*for[ ]*([^ ]+)[ ]*in[ ]*([^ ]+)[ ]*%}/);
        if (!loopData) {
          continue;
        }
        loopsData.push({
          itemName: loopData[1],
          sourceName: loopData[2]
        });
      }
      return loopsData;
    }
  }, {
    key: "getLoopItemVariables",
    value: function getLoopItemVariables(variableParts, scope) {
      var mainKey = variableParts[0];
      var subKey = variableParts[1];
      scope = scope.hasOwnProperty(mainKey) ? scope[mainKey] : {};
      return scope.hasOwnProperty(subKey) && scope[subKey].length > 0 ? scope[subKey][0] : {};
    }
  }, {
    key: "getLoopVariablesAutocomplete",
    value: function getLoopVariablesAutocomplete(nameParts, lineNumber, session, isGlobalVar) {
      var _this = this;
      var variablesInfo = [];
      // [ { itemName: 'image_item', sourceName: 'item.gallery.value' }, { itemName: 'item', sourceName: 'repeater.value' }, ] OR
      // [ { itemName: 'item', sourceName: 'repeater.value' }, ]
      var parentLoopsData = this.getCurrentLoops(lineNumber, session);
      if (isGlobalVar) {
        parentLoopsData.forEach(function (loopData) {
          variablesInfo.push(_this.makeAutocompleteItem(loopData.itemName, null, 2000, 'loop object'));
        });
        return variablesInfo;
      }
      // only for the direct items and their properties
      // [ 'image_item', ] OR
      // [ 'item', 'gallery', ]
      if (nameParts.length > 2) {
        return [];
      }
      var loopScopeIndex = -1;
      var itemName = nameParts[0];
      parentLoopsData.forEach(function (loopData, index) {
        if (itemName !== loopData.itemName) {
          return;
        }
        loopScopeIndex = index;
      });
      if (-1 === loopScopeIndex) {
        return [];
      }
      // ['repeater', 'value', ] OR
      // ['item', 'gallery', 'value', ]
      var loopScopeParts = parentLoopsData[loopScopeIndex].sourceName.split('.');
      var autoCompleteData = {};
      switch (loopScopeParts.length) {
        // ['repeater', 'value', ]
        case 2:
          autoCompleteData = this.getLoopItemVariables(loopScopeParts, this.autocompleteVariables);
          if (2 === nameParts.length) {
            var propertyName = nameParts[1];
            autoCompleteData = autoCompleteData.hasOwnProperty(propertyName) ? autoCompleteData[propertyName] : {};
          }
          break;
        // ['item', 'gallery', 'value', ]
        case 3:
          var parentLoopScoreIndex = loopScopeIndex + 1;
          // no parent loops
          if (parentLoopScoreIndex >= parentLoopsData.length) {
            return [];
          }
          // 'repeater.value'
          var mainKey = parentLoopsData[parentLoopScoreIndex].sourceName;
          autoCompleteData = this.getLoopItemVariables(mainKey.split('.'), this.autocompleteVariables);
          // remove first item from loopScopeParts
          // 'item' from ['item', 'gallery', 'value', ]
          loopScopeParts.shift();
          autoCompleteData = this.getLoopItemVariables(loopScopeParts, autoCompleteData);
          break;
      }
      for (var variableName in autoCompleteData) {
        variablesInfo.push(this.makeAutocompleteItem(variableName, autoCompleteData[variableName], 2000));
      }
      return variablesInfo;
    }
  }, {
    key: "getVariablesAutocomplete",
    value: function getVariablesAutocomplete(variableName, lineNumber, session) {
      // ignore filters
      if (-1 !== variableName.indexOf('|')) {
        return [];
      }
      var nameParts = variableName.split('.');
      var isGlobalVar = true;
      // return global variables
      if (1 !== nameParts.length) {
        // remove the current, as it's object to be completed
        nameParts.pop();
        isGlobalVar = false;
      }
      return [].concat(_toConsumableArray(this.getContextVariablesAutocomplete(nameParts, isGlobalVar)), _toConsumableArray(this.getLoopVariablesAutocomplete(nameParts, lineNumber, session, isGlobalVar)));
    }
  }, {
    key: "getFunctionsAutocomplete",
    value: function getFunctionsAutocomplete(functionName) {
      // ignore filters
      if (-1 !== functionName.indexOf('|')) {
        return [];
      }
      var nameParts = functionName.split('.');
      // ignore variables
      if (1 !== nameParts.length) {
        return [];
      }
      var functionsAutocomplete = [];
      for (var _functionName in this.autocompleteFunctions) {
        functionsAutocomplete.push(this.makeAutocompleteItem(_functionName + '()', null, 1000, null, _functionName + this.autocompleteFunctions[_functionName]));
      }
      return functionsAutocomplete;
    }
  }, {
    key: "getFiltersAutocomplete",
    value: function getFiltersAutocomplete(filterName) {
      // ignore variables and functions
      if (-1 === filterName.indexOf('|')) {
        return [];
      }
      var filtersAutocomplete = [];
      for (var _filterName in this.autocompleteFilters) {
        filtersAutocomplete.push(this.makeAutocompleteItem(_filterName, null, 1000, null, _filterName + this.autocompleteFilters[_filterName]));
      }
      return filtersAutocomplete;
    }
  }, {
    key: "updateAutocompleteData",
    value: function updateAutocompleteData(autocompleteData) {
      this.autocompleteVariables = autocompleteData;
    }
  }, {
    key: "getCompletions",
    value: function getCompletions(editor, session, pos, prefix, callback) {
      var currentLine = session.getLine(pos.row);
      if (!this.isTwigLine(currentLine)) {
        return;
      }
      var spaceIndex = currentLine.lastIndexOf(' ', pos.column - 1);
      var variableName = currentLine.substring(spaceIndex + 1, pos.column);
      var autocomplete = [].concat(_toConsumableArray(this.getVariablesAutocomplete(variableName, pos.row, session)), _toConsumableArray(this.getFunctionsAutocomplete(variableName)), _toConsumableArray(this.getFiltersAutocomplete(variableName)));
      callback(null, autocomplete);
    }
  }]);
  return VariableAutoCompleter;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VariableAutoCompleter);

/***/ }),

/***/ "./lite/admin/js/cpt-item/view.ts":
/*!****************************************!*\
  !*** ./lite/admin/js/cpt-item/view.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _postbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./postbox */ "./lite/admin/js/cpt-item/postbox.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings */ "./lite/admin/js/cpt-item/settings.ts");
/* harmony import */ var _preview__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./preview */ "./lite/admin/js/cpt-item/preview.ts");
/* harmony import */ var _field_select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./field-select */ "./lite/admin/js/cpt-item/field-select.ts");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var VIEW_DATA = {
  POST_BOX: '#acf-local_acf_views_view',
  PREVIEW_TAB: '#acf-local_acf_views_view li .acf-tab-button[data-key=local_acf_views_view__preview-tab]',
  PREVIEW_FIELD: '#acf-local_acf_views_view__preview'
};
var View = /*#__PURE__*/function (_PostBox) {
  _inherits(View, _PostBox);
  var _super = _createSuper(View);
  function View() {
    _classCallCheck(this, View);
    return _super.apply(this, arguments);
  }
  _createClass(View, [{
    key: "initialize",
    value: function initialize() {
      _get(_getPrototypeOf(View.prototype), "initialize", this).call(this);
      if (!document.body.querySelector(VIEW_DATA.POST_BOX)) {
        return;
      }
      this.init();
      this.initializePreview();
    }
  }, {
    key: "createFieldSelects",
    value: function createFieldSelects() {
      _get(_getPrototypeOf(View.prototype), "createFieldSelects", this).call(this);
      new _field_select__WEBPACK_IMPORTED_MODULE_3__["default"]('acf-local_acf_views_view__group', 'acf-local_acf_views_view__parent-field', '', false, true);
    }
  }, {
    key: "initializePreview",
    value: function initializePreview() {
      if (!_settings__WEBPACK_IMPORTED_MODULE_1__["default"].hasOwnProperty('viewPreview') || !_settings__WEBPACK_IMPORTED_MODULE_1__["default"].viewPreview.hasOwnProperty('HTML') || !_settings__WEBPACK_IMPORTED_MODULE_1__["default"].viewPreview.hasOwnProperty('CSS') || !_settings__WEBPACK_IMPORTED_MODULE_1__["default"].viewPreview.hasOwnProperty('HOME')) {
        console.log('Preview properties are missing');
        return;
      }
      var preview = new _preview__WEBPACK_IMPORTED_MODULE_2__["default"](VIEW_DATA.PREVIEW_TAB, VIEW_DATA.PREVIEW_FIELD, _settings__WEBPACK_IMPORTED_MODULE_1__["default"].viewPreview['HTML'], _settings__WEBPACK_IMPORTED_MODULE_1__["default"].viewPreview['CSS'], _settings__WEBPACK_IMPORTED_MODULE_1__["default"].viewPreview['HOME']);
      preview.initialize();
    }
  }]);
  return View;
}(_postbox__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (View);

/***/ }),

/***/ "./lite/admin/js/cpt-item/web-component.ts":
/*!*************************************************!*\
  !*** ./lite/admin/js/cpt-item/web-component.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var WebComponent = /*#__PURE__*/function (_HTMLElement) {
  _inherits(WebComponent, _HTMLElement);
  var _super = _createSuper(WebComponent);
  function WebComponent() {
    _classCallCheck(this, WebComponent);
    return _super.apply(this, arguments);
  }
  _createClass(WebComponent, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      'loading' === document.readyState ? document.addEventListener('DOMContentLoaded', this.initialize.bind(this)) : this.initialize();
    }
  }, {
    key: "initialize",
    value: function initialize() {}
  }]);
  return WebComponent;
}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebComponent);

/***/ }),

/***/ "./lite/admin/css/tools.scss":
/*!***********************************!*\
  !*** ./lite/admin/css/tools.scss ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./lite/admin/css/editor.scss":
/*!************************************!*\
  !*** ./lite/admin/css/editor.scss ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./lite/admin/css/dashboard.scss":
/*!***************************************!*\
  !*** ./lite/admin/css/dashboard.scss ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./lite/admin/css/common.scss":
/*!************************************!*\
  !*** ./lite/admin/css/common.scss ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./lite/admin/css/list-page.scss":
/*!***************************************!*\
  !*** ./lite/admin/css/list-page.scss ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./lite/admin/css/cpt-item.scss":
/*!**************************************!*\
  !*** ./lite/admin/css/cpt-item.scss ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrow: () => (/* binding */ arrow),
/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),
/* harmony export */   computePosition: () => (/* binding */ computePosition),
/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),
/* harmony export */   flip: () => (/* binding */ flip),
/* harmony export */   hide: () => (/* binding */ hide),
/* harmony export */   inline: () => (/* binding */ inline),
/* harmony export */   limitShift: () => (/* binding */ limitShift),
/* harmony export */   offset: () => (/* binding */ offset),
/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),
/* harmony export */   shift: () => (/* binding */ shift),
/* harmony export */   size: () => (/* binding */ size)
/* harmony export */ });
/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs");



function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);
  const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);
  const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);
  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
  const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);
    const coords = {
      x,
      y
    };
    const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);
    const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === 'y';
    const minProp = isYAxis ? 'top' : 'left';
    const maxProp = isYAxis ? 'bottom' : 'right';
    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

    // DOM platform can return `window` as the `offsetParent`.
    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min$1 = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. To ensure `shift()` continues to take action,
    // a single reset is performed when this is true.
    const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset
        })
      },
      reset: shouldAddOffset
    };
  }
});

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment), ...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)] : allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map(d => {
        const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);
        return [d.placement, alignment && crossAxis ?
        // Check along the mainAxis and main crossAxis side.
        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
        // Check only the mainAxis.
        d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
      // Aligned placements should not check their opposite crossAxis
      // side.
      (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every(v => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
      const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {
        fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$map$so;
                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

function getBoundingRect(rects) {
  const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.left));
  const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.top));
  const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.right));
  const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map(rect => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'inline',
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = state;
      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
      // ClientRect's bounds, despite the event listener being triggered. A
      // padding of 2 seems to handle this issue.
      const {
        padding = 2,
        x,
        y
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));
      const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);
      function getBoundingClientRect() {
        // There are two rects and they are disjoined.
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          // Find the first rect in which the point is fully inside.
          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }

        // There are 2 or more connected rects.
        if (clientRects.length >= 2) {
          if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y') {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'top';
            const top = firstRect.top;
            const bottom = lastRect.bottom;
            const left = isTop ? firstRect.left : lastRect.left;
            const right = isTop ? firstRect.right : lastRect.right;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }
          const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'left';
          const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map(rect => rect.right));
          const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map(rect => rect.left));
          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
  const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);
  const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));
      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);
      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = ['top', 'left'].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
      const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);
      const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);
        const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);
        const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);
        const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};




/***/ }),

/***/ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow),
/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),
/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),
/* harmony export */   computePosition: () => (/* binding */ computePosition),
/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),
/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip),
/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),
/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide),
/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline),
/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift),
/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),
/* harmony export */   platform: () => (/* binding */ platform),
/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift),
/* harmony export */   size: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size)
/* harmony export */ });
/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/utils */ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs");
/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ "./node_modules/@floating-ui/core/dist/floating-ui.core.mjs");
/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils/dom */ "./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs");






function getCssDimensions(element) {
  const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}

function unwrapElement(element) {
  return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(element) ? element.contextElement : element;
}

function getScale(element) {
  const domElement = unwrapElement(element);
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(domElement)) {
    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.width) : rect.width) / width;
  let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

const noOffsets = /*#__PURE__*/(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);
function getVisualOffsets(element) {
  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element)) {
    return false;
  }
  return isFixed;
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);
  if (includeScale) {
    if (offsetParent) {
      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(domElement);
    const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(currentIFrame).frameElement;
    }
  }
  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)({
    width,
    height,
    x,
    y
  });
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);
  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);
  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {
      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);
    }
    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}

function getClientRects(element) {
  return Array.from(element.getClientRects());
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element)).left + (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element).scrollLeft;
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);
  const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element);
  const body = element.ownerDocument.body;
  const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(body).direction === 'rtl') {
    x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getViewportRect(element, strategy) {
  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);
  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element));
  } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element);
  if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(parentNode)) {
    return false;
  }
  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(element, [], false).filter(el => (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === 'fixed';
  let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(currentNode)) {
    const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentNode);
    const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.top, accRect.top);
    accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.right, accRect.right);
    accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.bottom, accRect.bottom);
    accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  return getCssDimensions(element);
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);
  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {
      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function getTrueOffsetParent(element, polyfill) {
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const window = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element)) {
    return window;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isTableElement)(offsetParent) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === 'html' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === 'body' && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === 'static' && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(offsetParent))) {
    return window;
  }
  return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getContainingBlock)(element) || window;
}

const getElementRects = async function (_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...(await getDimensionsFn(floating))
    }
  };
};

function isRTL(element) {
  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).direction === 'rtl';
}

const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement,
  isRTL
};

// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(top);
    const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientWidth - (left + width));
    const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientHeight - (top + height));
    const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }

    // Older browsers don't support a `document` as the root and will throw an
    // error.
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(referenceEl) : []), ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        // Prevent update loops when using the `size` middleware.
        // https://github.com/floating-ui/floating-ui/issues/1740
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};




/***/ }),

/***/ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alignments: () => (/* binding */ alignments),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   createCoords: () => (/* binding */ createCoords),
/* harmony export */   evaluate: () => (/* binding */ evaluate),
/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   getAlignment: () => (/* binding */ getAlignment),
/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),
/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),
/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),
/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),
/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),
/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),
/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),
/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),
/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),
/* harmony export */   getSide: () => (/* binding */ getSide),
/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   placements: () => (/* binding */ placements),
/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sides: () => (/* binding */ sides)
/* harmony export */ });
const sides = ['top', 'right', 'bottom', 'left'];
const alignments = ['start', 'end'];
const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}




/***/ }),

/***/ "./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),
/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),
/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),
/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),
/* harmony export */   getNodeName: () => (/* binding */ getNodeName),
/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),
/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),
/* harmony export */   getParentNode: () => (/* binding */ getParentNode),
/* harmony export */   getWindow: () => (/* binding */ getWindow),
/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),
/* harmony export */   isElement: () => (/* binding */ isElement),
/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),
/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),
/* harmony export */   isNode: () => (/* binding */ isNode),
/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),
/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),
/* harmony export */   isTableElement: () => (/* binding */ isTableElement),
/* harmony export */   isWebKit: () => (/* binding */ isWebKit)
/* harmony export */ });
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  // Browsers without `ShadowRoot` support.
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle(element);

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/Assets/admin/js/cpt-item.min": 0,
/******/ 			"Assets/admin/css/cpt-item.min": 0,
/******/ 			"Assets/admin/css/list-page.min": 0,
/******/ 			"Assets/admin/css/common.min": 0,
/******/ 			"Assets/admin/css/dashboard.min": 0,
/******/ 			"Assets/admin/css/editor.min": 0,
/******/ 			"Assets/admin/css/tools.min": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkorigin_assets"] = self["webpackChunkorigin_assets"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["Assets/admin/css/cpt-item.min","Assets/admin/css/list-page.min","Assets/admin/css/common.min","Assets/admin/css/dashboard.min","Assets/admin/css/editor.min","Assets/admin/css/tools.min"], () => (__webpack_require__("./lite/admin/js/cpt-item.ts")))
/******/ 	__webpack_require__.O(undefined, ["Assets/admin/css/cpt-item.min","Assets/admin/css/list-page.min","Assets/admin/css/common.min","Assets/admin/css/dashboard.min","Assets/admin/css/editor.min","Assets/admin/css/tools.min"], () => (__webpack_require__("./lite/admin/css/dashboard.scss")))
/******/ 	__webpack_require__.O(undefined, ["Assets/admin/css/cpt-item.min","Assets/admin/css/list-page.min","Assets/admin/css/common.min","Assets/admin/css/dashboard.min","Assets/admin/css/editor.min","Assets/admin/css/tools.min"], () => (__webpack_require__("./lite/admin/css/common.scss")))
/******/ 	__webpack_require__.O(undefined, ["Assets/admin/css/cpt-item.min","Assets/admin/css/list-page.min","Assets/admin/css/common.min","Assets/admin/css/dashboard.min","Assets/admin/css/editor.min","Assets/admin/css/tools.min"], () => (__webpack_require__("./lite/admin/css/list-page.scss")))
/******/ 	__webpack_require__.O(undefined, ["Assets/admin/css/cpt-item.min","Assets/admin/css/list-page.min","Assets/admin/css/common.min","Assets/admin/css/dashboard.min","Assets/admin/css/editor.min","Assets/admin/css/tools.min"], () => (__webpack_require__("./lite/admin/css/cpt-item.scss")))
/******/ 	__webpack_require__.O(undefined, ["Assets/admin/css/cpt-item.min","Assets/admin/css/list-page.min","Assets/admin/css/common.min","Assets/admin/css/dashboard.min","Assets/admin/css/editor.min","Assets/admin/css/tools.min"], () => (__webpack_require__("./lite/admin/css/tools.scss")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["Assets/admin/css/cpt-item.min","Assets/admin/css/list-page.min","Assets/admin/css/common.min","Assets/admin/css/dashboard.min","Assets/admin/css/editor.min","Assets/admin/css/tools.min"], () => (__webpack_require__("./lite/admin/css/editor.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;